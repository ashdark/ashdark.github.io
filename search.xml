<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[认识docker-compose（一）配置文件详解]]></title>
      <url>/2017/08/26/%E8%AE%A4%E8%AF%86docker-compose%EF%BC%88%E4%B8%80%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="docker-compose-yml-配置文件（约定的-docker-compose-配置文件的名字）"><a href="#docker-compose-yml-配置文件（约定的-docker-compose-配置文件的名字）" class="headerlink" title="docker-compose.yml 配置文件（约定的 docker-compose 配置文件的名字）"></a>docker-compose.yml 配置文件（约定的 docker-compose 配置文件的名字）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">version: &quot;2.0&quot;</div><div class="line">services:</div><div class="line">    web:</div><div class="line">      image: ubuntu:16.04</div><div class="line">      ports:</div><div class="line">        - &quot;80:80&quot;</div><div class="line">        - &quot;443:443&quot;</div><div class="line">        - &quot;9000:9000&quot;</div><div class="line">      links:</div><div class="line">        - mysql:mysql</div><div class="line">        - mongo:mongo</div><div class="line">        - memcached:memcached</div><div class="line">        - redis:redis</div><div class="line">        - elasticsearch:elasticsearch</div><div class="line">        - rabbitmq:rabbitmq</div><div class="line">      volumes:</div><div class="line">        - ./www:/var/www</div><div class="line">        - ./sites:/etc/nginx/conf.d</div><div class="line">        - ./logs:/var/log/supervisor</div><div class="line">    </div><div class="line">    mysql:</div><div class="line">      image: mysql</div><div class="line">      ports:</div><div class="line">        - &quot;3306:3306&quot;</div><div class="line">      environment:</div><div class="line">        MYSQL_ROOT_PASSWORD: password</div><div class="line">    </div><div class="line">    mongo:</div><div class="line">      image: mongo</div><div class="line">      ports:</div><div class="line">        - &quot;27017:27017&quot;</div><div class="line">    </div><div class="line">    memcached:</div><div class="line">      image: memcached</div><div class="line">      ports:</div><div class="line">        - &quot;11211:11211&quot;</div><div class="line">    </div><div class="line">    redis:</div><div class="line">      image: redis</div><div class="line">      ports:</div><div class="line">        - &quot;6379:6379&quot;</div><div class="line">    </div><div class="line">    elasticsearch:</div><div class="line">      image: elasticsearch</div><div class="line">      ports:</div><div class="line">        - &quot;9200:9200&quot;</div><div class="line">        - &quot;9300:9300&quot;</div><div class="line">    </div><div class="line">    rabbitmq:</div><div class="line">      image: rabbitmq:3.6.1-management</div><div class="line">      ports:</div><div class="line">        - &quot;15672:15672&quot;</div><div class="line">        - &quot;5672:5672&quot;</div></pre></td></tr></table></figure>
<p>一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，下面先来看 services 的书写规则。</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>这里是的version是配置文件的版本号，每个版本的配置文件格式有所不同</p>
<h2 id="services"><a href="#services" class="headerlink" title="services"></a>services</h2><p>编排各个服务</p>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。<br>image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。</p>
<pre><code>build: /path/to/build/dir
</code></pre><p>也可以是相对路径，只要上下文确定就可以读取到 Dockerfile。</p>
<pre><code>build: ./dir
</code></pre><p>设定上下文根目录，然后以该目录为准指定 Dockerfile。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">build:</div><div class="line">  context: ../</div><div class="line">  dockerfile: path/of/Dockerfile</div></pre></td></tr></table></figure>
<p>注意 build 都是一个目录，如果你要指定 Dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定，如上面的例子。<br>如果你同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">build: ./dir</div><div class="line">image: webapp:tag</div></pre></td></tr></table></figure>
<p>既然可以在 docker-compose.yml 中定义构建任务，那么一定少不了 arg 这个标签，就像 Dockerfile 中的 ARG 指令，它可以在构建过程中指定环境变量，但是在构建成功后取消，在 docker-compose.yml 文件中也支持这样的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">build:</div><div class="line">  context: .</div><div class="line">  args:</div><div class="line">    buildno: 1</div><div class="line">    password: secret</div></pre></td></tr></table></figure>
<p>下面这种写法也是支持的，一般来说下面的写法更适合阅读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">build:</div><div class="line">  context: .</div><div class="line">  args:</div><div class="line">    - buildno=1</div><div class="line">    - password=secret</div></pre></td></tr></table></figure>
<p>与 ENV 不同的是，ARG 是允许空值的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">args:</div><div class="line">  - buildno</div><div class="line">  - password</div></pre></td></tr></table></figure>
<p>这样构建过程可以向它们赋值。</p>
<blockquote>
<p>注意：YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。</p>
</blockquote>
<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>使用 command 可以覆盖容器启动后默认执行的命令。</p>
<pre><code>command: bundle exec thin -p 3000
</code></pre><p>也可以写成类似 Dockerfile 中的格式：</p>
<pre><code>command: [bundle, exec, thin, -p, 3000]
</code></pre><h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h2><p>前面说过 Compose 的容器名称格式是：&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt;<br>虽然可以自定义项目名称、服务名称，但是如果你想完全控制容器的命名，可以使用这个标签指定：</p>
<pre><code>container_name: app
</code></pre><p>这样容器的名字就指定为 app 了。</p>
<h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><p>在使用 Compose 时，最大的好处就是少打启动命令，但是一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。<br>例如在没启动数据库容器的时候启动了应用容器，这时候应用容器会因为找不到数据库而退出，为了避免这种情况我们需要加入一个标签，就是 depends_on，这个标签解决了容器的依赖、启动先后的问题。<br>例如下面容器会先启动 redis 和 db 两个服务，最后才启动 web 服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &apos;2&apos;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    build: .</div><div class="line">    depends_on:</div><div class="line">      - db</div><div class="line">      - redis</div><div class="line">  redis:</div><div class="line">    image: redis</div><div class="line">  db:</div><div class="line">    image: postgres</div></pre></td></tr></table></figure>
<p>注意的是，默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系。</p>
<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>和 –dns 参数一样用途，格式如下：</p>
<pre><code>dns: 8.8.8.8
</code></pre><p>也可以是一个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dns:</div><div class="line">  - 8.8.8.8</div><div class="line">  - 9.9.9.9</div></pre></td></tr></table></figure></p>
<p>此外 dns_search 的配置也类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dns_search: example.com</div><div class="line">dns_search:</div><div class="line">  - dc1.example.com</div><div class="line">  - dc2.example.com</div></pre></td></tr></table></figure></p>
<h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>挂载临时目录到容器内部，与 run 的参数一样效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmpfs: /run</div><div class="line">tmpfs:</div><div class="line">  - /run</div><div class="line">  - /tmp</div></pre></td></tr></table></figure></p>
<h2 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h2><p>在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，第四章有对比过与 CMD 的区别。<br>在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义：</p>
<pre><code>entrypoint: /code/entrypoint.sh
</code></pre><p>格式和 Docker 类似，不过还可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">entrypoint:</div><div class="line">    - php</div><div class="line">    - -d</div><div class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</div><div class="line">    - -d</div><div class="line">    - memory_limit=-1</div><div class="line">    - vendor/bin/phpunit</div></pre></td></tr></table></figure>
<h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h2><p>docker-compose.yml 中可以定义一个专门存放变量的文件。<br>如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。</p>
<p>如果有变量名称与 environment 指令冲突，则以后者为准。格式如下：</p>
<pre><code>env_file: .env
</code></pre><p>或者根据 docker-compose.yml 设置多个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">env_file:</div><div class="line">  - ./common.env</div><div class="line">  - ./apps/web.env</div><div class="line">  - /opt/secrets.env</div></pre></td></tr></table></figure>
<p>注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。</p>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。<br>一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">environment:</div><div class="line">  RACK_ENV: development</div><div class="line">  SHOW: &apos;true&apos;</div><div class="line">  SESSION_SECRET:</div><div class="line"></div><div class="line">environment:</div><div class="line">  - RACK_ENV=development</div><div class="line">  - SHOW=true</div><div class="line">  - SESSION_SECRET</div></pre></td></tr></table></figure>
<h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">expose:</div><div class="line"> - &quot;3000&quot;</div><div class="line"> - &quot;8000&quot;</div></pre></td></tr></table></figure></p>
<h2 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h2><p>在使用Docker过程中，我们会有许多单独使用docker run启动的容器，为了使Compose能够连接这些不在docker-compose.yml中定义的容器，我们需要一个特殊的标签，就是external_links，它可以让Compose项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">external_links:</div><div class="line"> - redis_1</div><div class="line"> - project_db_1:mysql</div><div class="line"> - project_db_1:postgresql</div></pre></td></tr></table></figure>
<h2 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h2><p>添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的–add-host类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extra_hosts:</div><div class="line"> - &quot;somehost:162.242.195.82&quot;</div><div class="line"> - &quot;otherhost:50.31.209.229&quot;</div></pre></td></tr></table></figure>
<p>启动之后查看容器内部hosts： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">162.242.195.82  somehost</div><div class="line">50.31.209.229   otherhost</div></pre></td></tr></table></figure>
<h2 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h2><p>向容器添加元数据，和Dockerfile的LABEL指令一个意思，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">labels:</div><div class="line">   com.example.description: &quot;Accounting webapp&quot;</div><div class="line">   com.example.department: &quot;Finance&quot;</div><div class="line">   com.example.label-with-empty-value: &quot;&quot;</div><div class="line"> labels:</div><div class="line">   - &quot;com.example.description=Accounting webapp&quot;</div><div class="line">   - &quot;com.example.department=Finance&quot;</div><div class="line">   - &quot;com.example.label-with-empty-value&quot;</div></pre></td></tr></table></figure>
<h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><p>还记得上面的depends_on吧，那个标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与Docker client的–link一样效果，会连接到其它服务中的容器。<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">links:</div><div class="line"> - db</div><div class="line"> - db:database</div><div class="line"> - redis</div></pre></td></tr></table></figure>
<p>使用的别名将会自动在服务容器中的/etc/hosts里创建。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">172.12.2.186  db</div><div class="line">172.12.2.186  database</div><div class="line">172.12.2.187  redis</div></pre></td></tr></table></figure>
<p>相应的环境变量也将被创建。</p>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>这个标签用于配置日志服务。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">logging:</div><div class="line">  driver: syslog</div><div class="line">  options:</div><div class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</div></pre></td></tr></table></figure>
<p>默认的driver是json-file。只有json-file和journald可以通过docker-compose logs显示日志，其他方式有其他日志查看方式，但目前Compose不支持。对于可选值可以使用options指定。</p>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><pre><code>pid: &quot;host&quot;
</code></pre><p>将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。</p>
<h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h2><p>映射端口的标签。<br>使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ports:</div><div class="line"> - &quot;3000&quot;</div><div class="line"> - &quot;8000:8000&quot;</div><div class="line"> - &quot;49100:22&quot;</div><div class="line"> - &quot;127.0.0.1:8001:8001&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：当使用HOST:CONTAINER格式来映射端口时，如果你使用的容器端口小于60你可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。<br>所以建议采用字符串格式。</p>
</blockquote>
<h2 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h2><p>为每个容器覆盖默认的标签。简单说来就是管理全部服务的标签。比如设置全部服务的user标签值为USER。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">security_opt:</div><div class="line">  - label:user:USER</div><div class="line">  - label:role:ROLE</div></pre></td></tr></table></figure>
<h2 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h2><p>设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器。设置另一个信号可以使用stop_signal标签。</p>
<pre><code>stop_signal: SIGUSR1
</code></pre><h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><p>挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER] 这样的格式，或者使用 [HOST:CONTAINER:ro] 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统。<br>Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。<br>数据卷的格式可以是下面多种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">volumes:</div><div class="line">  // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。</div><div class="line">  - /var/lib/mysql</div><div class="line"></div><div class="line">  // 使用绝对路径挂载数据卷</div><div class="line">  - /opt/data:/var/lib/mysql</div><div class="line"></div><div class="line">  // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。</div><div class="line">  - ./cache:/tmp/cache</div><div class="line"></div><div class="line">  // 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。</div><div class="line">  - ~/configs:/etc/configs/:ro</div><div class="line"></div><div class="line">  // 已经存在的命名的数据卷。</div><div class="line">  - datavolume:/var/lib/mysql</div></pre></td></tr></table></figure>
<p>如果你不使用宿主机的路径，你可以指定一个volume_driver。</p>
<h2 id="volumes-from"><a href="#volumes-from" class="headerlink" title="volumes_from"></a>volumes_from</h2><p>从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">volumes_from:</div><div class="line">  - service_name</div><div class="line">  - service_name:ro</div><div class="line">  - container:container_name</div><div class="line">  - container:container_name:rw</div></pre></td></tr></table></figure>
<h2 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h2><p>添加或删除容器的内核功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cap_add:</div><div class="line">  - ALL</div><div class="line"></div><div class="line">cap_drop:</div><div class="line">  - NET_ADMIN</div><div class="line">  - SYS_ADMIN</div></pre></td></tr></table></figure>
<h2 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h2><p>指定一个容器的父级cgroup。</p>
<pre><code>cgroup_parent: m-executor-abcd
</code></pre><h2 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h2><p>设备映射列表。与Docker client的–device参数类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">devices:</div><div class="line">  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</div></pre></td></tr></table></figure>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>这个标签可以扩展另一个服务，扩展内容可以是来自在当前文件，也可以是来自其他文件，相同服务的情况下，后来者会有选择地覆盖原有配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extends:</div><div class="line">  file: common.yml</div><div class="line">  service: webapp</div></pre></td></tr></table></figure>
<p>用户可以在任何地方使用这个标签，只要标签内容包含file和service两个值就可以了。file的值可以是相对或者绝对路径，如果不指定file的值，那么Compose会读取当前YML文件的信息。</p>
<h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h2><p>网络模式，与Docker client的–net参数类似，只是相对多了一个service:[service name] 的格式。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">network_mode: &quot;bridge&quot;</div><div class="line">network_mode: &quot;host&quot;</div><div class="line">network_mode: &quot;none&quot;</div><div class="line">network_mode: &quot;service:[service name]&quot;</div><div class="line">network_mode: &quot;container:[container name/id]&quot;</div></pre></td></tr></table></figure>
<p>可以指定使用服务或者容器的网络。</p>
<h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>加入指定网络，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">services:</div><div class="line">  some-service:</div><div class="line">    networks:</div><div class="line">     - some-network</div><div class="line">     - other-network</div></pre></td></tr></table></figure>
<p>关于这个标签还有一个特别的子标签aliases，这是一个用来设置服务别名的标签，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">services:</div><div class="line">  some-service:</div><div class="line">    networks:</div><div class="line">      some-network:</div><div class="line">        aliases:</div><div class="line">         - alias1</div><div class="line">         - alias3</div><div class="line">      other-network:</div><div class="line">        aliases:</div><div class="line">         - alias2</div></pre></td></tr></table></figure>
<p>相同的服务可以在不同的网络有不同的别名。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有这些标签：cpu_shares, cpu_quota, cpuset, domainname, hostname, ipc, mac_address, mem_limit, memswap_limit, privileged, read_only, restart, shm_size, stdin_open, tty, user, working_dir<br>上面这些都是一个单值的标签，类似于使用docker run的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">cpu_shares: 73</div><div class="line">cpu_quota: 50000</div><div class="line">cpuset: 0,1</div><div class="line"></div><div class="line">user: postgresql</div><div class="line">working_dir: /code</div><div class="line"></div><div class="line">domainname: foo.com</div><div class="line">hostname: foo</div><div class="line">ipc: host</div><div class="line">mac_address: 02:42:ac:11:65:43</div><div class="line"></div><div class="line">mem_limit: 1000000000</div><div class="line">memswap_limit: 2000000000</div><div class="line">privileged: true</div><div class="line"></div><div class="line">restart: always</div><div class="line"></div><div class="line">read_only: true</div><div class="line">shm_size: 64M</div><div class="line">stdin_open: true</div><div class="line">tty: true</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员优雅的使用windows10]]></title>
      <url>/2017/05/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8windows10/</url>
      <content type="html"><![CDATA[<h2 id="工欲善其事必先利其器"><a href="#工欲善其事必先利其器" class="headerlink" title="工欲善其事必先利其器"></a>工欲善其事必先利其器</h2><blockquote>
<p>个人认为MAC对程序开发是比较友好的，跟linux的环境也差不多，开发起来非常舒畅<br>但是在公司的情况，有时候提供给我们的是Windows<br>以下列出的就是我寄几在Windows上的工具用以记录和分享</p>
</blockquote>
<h2 id="Cmder-官网"><a href="#Cmder-官网" class="headerlink" title="Cmder  官网"></a>Cmder  <a href="http://cmder.net/" target="_blank" rel="external">官网</a></h2><blockquote>
<p>windows必备神器<br>支持PowerShell<br>告别自带cmd,拥抱Cmder<br>可以当做是Windows下的终端</p>
</blockquote>
<h2 id="Wox-官网"><a href="#Wox-官网" class="headerlink" title="Wox  官网"></a>Wox  <a href="http://www.getwox.com/" target="_blank" rel="external">官网</a></h2><blockquote>
<p>Windows下一款最接近 Alfred 的软件启动/文件搜索利器<br>拥有许多插件，可以自由组合</p>
</blockquote>
<h2 id="Docker-官网"><a href="#Docker-官网" class="headerlink" title="Docker  官网"></a>Docker  <a href="https://www.docker.com/" target="_blank" rel="external">官网</a></h2><blockquote>
<p>一个开源的应用容器引擎<br>让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上<br>也可以实现虚拟化<br>在本地配置linux开发环境,统一同事之间的开发环境，新同事入职只需将开发环境容器进行拷贝</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker常用命令]]></title>
      <url>/2017/04/30/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="pull-docker-镜像"><a href="#pull-docker-镜像" class="headerlink" title="pull docker 镜像"></a>pull docker 镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker pull centos:6.6</div></pre></td></tr></table></figure>
<h2 id="查看docker-镜像"><a href="#查看docker-镜像" class="headerlink" title="查看docker 镜像"></a>查看docker 镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">jun/lnmp            latest              bbb646441ce0        3 minutes ago       1.02 GB</div><div class="line">centos              7                   a8493f5f50ff        2 weeks ago         192 MB</div><div class="line">d4w/nsenter         latest              9e4f13a0901e        7 months ago        83.8 kB</div><div class="line">centos              6.6                 d03626170061        7 months ago        203 MB</div></pre></td></tr></table></figure>
<h2 id="在docker-index中搜索image（search）"><a href="#在docker-index中搜索image（search）" class="headerlink" title="在docker index中搜索image（search）"></a>在docker index中搜索image（search）</h2><pre><code># docker search seanlo
</code></pre><h2 id="运行centos镜像-bash"><a href="#运行centos镜像-bash" class="headerlink" title="运行centos镜像 bash"></a>运行centos镜像 bash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker run -it &lt;IMAGE ID&gt; /bin/bash</div></pre></td></tr></table></figure>
<h2 id="查看正在运行的docker-容器"><a href="#查看正在运行的docker-容器" class="headerlink" title="查看正在运行的docker 容器"></a>查看正在运行的docker 容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker ps</div></pre></td></tr></table></figure>
<h2 id="查看所有docker-容器"><a href="#查看所有docker-容器" class="headerlink" title="查看所有docker 容器"></a>查看所有docker 容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker ps -a</div></pre></td></tr></table></figure>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker rm &lt;CONTAINER ID&gt;</div></pre></td></tr></table></figure>
<h2 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker rm $(docker ps -q -a)</div></pre></td></tr></table></figure>
<h2 id="停止、启动、杀死一个容器"><a href="#停止、启动、杀死一个容器" class="headerlink" title="停止、启动、杀死一个容器"></a>停止、启动、杀死一个容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># docker stop &lt;容器名orID&gt;</div><div class="line"># docker start &lt;容器名orID&gt;</div><div class="line"># docker kill &lt;容器名orID&gt;</div></pre></td></tr></table></figure>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker rmi &lt;IMAGE ID&gt;</div></pre></td></tr></table></figure>
<h2 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker rmi $(docker images -q)</div></pre></td></tr></table></figure>
<h2 id="把一个容器提交为镜像"><a href="#把一个容器提交为镜像" class="headerlink" title="把一个容器提交为镜像"></a>把一个容器提交为镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker commit &lt;container-id&gt; &lt;image-name&gt;</div></pre></td></tr></table></figure>
<h2 id="导出-（export）"><a href="#导出-（export）" class="headerlink" title="导出 （export）"></a>导出 （export）</h2><blockquote>
<p>Export命令用于持久化容器（不是镜像）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sudo docker export &lt;CONTAINER ID&gt; &gt; /home/export.tar</div></pre></td></tr></table></figure>
<h2 id="保存-（save）"><a href="#保存-（save）" class="headerlink" title="保存 （save）"></a>保存 （save）</h2><blockquote>
<p>Save命令用于持久化镜像（不是容器）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker save &lt;IMAGE ID&gt; &gt; /home/save.tar</div></pre></td></tr></table></figure>
<h2 id="导入-（import）"><a href="#导入-（import）" class="headerlink" title="导入 （import）"></a>导入 （import）</h2><blockquote>
<p>从容器快照文件中再导入为镜像</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat export.tar | docker import - jun/lnmp:1.0</div></pre></td></tr></table></figure>
<h2 id="加载镜像-（load）"><a href="#加载镜像-（load）" class="headerlink" title="加载镜像 （load）"></a>加载镜像 （load）</h2><blockquote>
<p>加载保存的镜像</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker load &lt; /home/save.tar</div></pre></td></tr></table></figure>
<h2 id="运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例"><a href="#运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例" class="headerlink" title="运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例"></a>运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v /var/redmine/mysql:/var/lib/mysql sameersbn/redmine</div></pre></td></tr></table></figure>
<h2 id="一个容器连接到另一个容器"><a href="#一个容器连接到另一个容器" class="headerlink" title="一个容器连接到另一个容器"></a>一个容器连接到另一个容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker run -i -t --name sonar -d -link mmysql:db tpires/sonar-server sonar</div></pre></td></tr></table></figure>
<h2 id="连接到正在运行中的container（attach）"><a href="#连接到正在运行中的container（attach）" class="headerlink" title="连接到正在运行中的container（attach）"></a>连接到正在运行中的container（attach）</h2><blockquote>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p>
</blockquote>
<pre><code># docker attach --sig-proxy=false $CONTAINER_ID
</code></pre><h2 id="使用docker-attach进入Docker容器"><a href="#使用docker-attach进入Docker容器" class="headerlink" title="使用docker attach进入Docker容器"></a>使用docker attach进入Docker容器</h2><pre><code># docker attach &lt;CONTAINER ID&gt; 
</code></pre><h2 id="使用docker-exec进入Docker容器"><a href="#使用docker-exec进入Docker容器" class="headerlink" title="使用docker exec进入Docker容器"></a>使用docker exec进入Docker容器</h2><pre><code># docker exec -it &lt;CONTAINER ID&gt; /bin/bash  
</code></pre>]]></content>
      
        <categories>
            
            <category> docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用heroku搭建shadowsocks]]></title>
      <url>/2017/04/20/%E4%BD%BF%E7%94%A8heroku%E6%90%AD%E5%BB%BAshadowsocks/</url>
      <content type="html"><![CDATA[<h2 id="使用heroku搭建shadowsocks"><a href="#使用heroku搭建shadowsocks" class="headerlink" title="使用heroku搭建shadowsocks"></a>使用heroku搭建shadowsocks</h2><h3 id="注册heroku-com"><a href="#注册heroku-com" class="headerlink" title="注册heroku.com"></a>注册heroku.com</h3><p>heroku官网注册: <a href="https://www.heroku.com" target="_blank" rel="external">www.heroku.com</a></p>
<h3 id="下载安装Heroku-CLI"><a href="#下载安装Heroku-CLI" class="headerlink" title="下载安装Heroku CLI"></a>下载安装Heroku CLI</h3><p><img src="/images/posts/heroku-cli.png" alt="下载安装"></p>
<h3 id="登录heroku"><a href="#登录heroku" class="headerlink" title="登录heroku"></a>登录heroku</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ heroku login</div><div class="line">Enter your Heroku credentials.</div><div class="line">Email: example@example.com</div><div class="line">Password:</div><div class="line">...</div></pre></td></tr></table></figure>
<p>更多: <a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up" target="_blank" rel="external">开始heroku</a></p>
<h3 id="创建heroku应用"><a href="#创建heroku应用" class="headerlink" title="创建heroku应用"></a>创建heroku应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ heroku create app-name</div></pre></td></tr></table></figure>
<h3 id="下载Shadowsocks的Heroku专版，准备应用程序"><a href="#下载Shadowsocks的Heroku专版，准备应用程序" class="headerlink" title="下载Shadowsocks的Heroku专版，准备应用程序"></a>下载Shadowsocks的Heroku专版，准备应用程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/mrluanma/shadowsocks-heroku.git</div><div class="line">$ <span class="built_in">cd</span> shadowsocks-heroku</div><div class="line">$ git init</div><div class="line">$ git commit -m <span class="string">"init"</span></div></pre></td></tr></table></figure>
<h3 id="添加remote"><a href="#添加remote" class="headerlink" title="添加remote"></a>添加remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ heroku git:remote -a app-name</div></pre></td></tr></table></figure>
<h3 id="推送到heroku"><a href="#推送到heroku" class="headerlink" title="推送到heroku"></a>推送到heroku</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ heroku push heroku master</div></pre></td></tr></table></figure>
<h3 id="设置加密方法和密码，如：heroku-config-set-METHOD-rc4-KEY-PASSWORD"><a href="#设置加密方法和密码，如：heroku-config-set-METHOD-rc4-KEY-PASSWORD" class="headerlink" title="设置加密方法和密码，如：heroku config:set METHOD=rc4 KEY=PASSWORD"></a>设置加密方法和密码，如：heroku config:set METHOD=rc4 KEY=PASSWORD</h3><h4 id="加密方法推荐rc4和aes-256-cfb"><a href="#加密方法推荐rc4和aes-256-cfb" class="headerlink" title="加密方法推荐rc4和aes-256-cfb"></a>加密方法推荐rc4和aes-256-cfb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ heroku config:<span class="built_in">set</span> METHOD=加密方法 KEY=密码</div></pre></td></tr></table></figure>
<h4 id="运行，如：node-local-js-s-appname-herokuapp-com-l-1080-m-rc4-k-PASSWORD-r-80"><a href="#运行，如：node-local-js-s-appname-herokuapp-com-l-1080-m-rc4-k-PASSWORD-r-80" class="headerlink" title="运行，如：node local.js -s appname.herokuapp.com -l 1080 -m rc4 -k PASSWORD -r 80"></a>运行，如：node local.js -s appname.herokuapp.com -l 1080 -m rc4 -k PASSWORD -r 80</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node local.js -s 应用名称.herokuapp.com -l 本地端口 -m 加密方法 -k 密码 -r 80</div></pre></td></tr></table></figure>
<pre><code>修改代理设置 SOCKS5 127.0.0.1:1080
</code></pre><p><a href="https://github.com/mrluanma/shadowsocks-heroku" target="_blank" rel="external">详细介绍</a></p>
]]></content>
      
        <categories>
            
            <category> shadowsocks </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heroku </tag>
            
            <tag> shadowsocks </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
